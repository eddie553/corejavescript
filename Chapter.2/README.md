# Chapter.2

## 실행 컨텍스트

### ex. 2-1

실행 컨텍스트 : 실행할 코드에 제공할 환경 정보들을 모아놓은 객체

콜 스택 : 코드 실행 시 필요한 실행 컨텍스트를 구성하여 쌓아놓은 스택

[콜 스택] - 예제 2-1
전역 컨텍스트 -> outer -> inner 순으로 스택에 쌓이고 반대 순서로 스택에서 빠져나간다.

- 실행 컨텍스트 구성

  - VariableEnvironment

    - environmentRecord(snapshot)
    - outerEnvironmentReference(snapshot)

  - LexicalEnvironment

    - environmentRecord
    - outerEnvironmentReference

  - ThisBinding

### ex. 2-2

[호이스팅]

자바스크립트 실행 이해하기

1. declaration 찾기 = 호이스팅
   선언은 function, identifier, 등을 순서대로 수집한다.
2. expression = 실행
   할당, 함수 실행 등의 코드를 실행한다.

### ex. 2-3

[호이스팅]
2-2 예제를 매개변수를 변수 선언/할당과 같다고 간주해서 변환한 예제
호이스팅에서는 변수명만 끌어올리고 할당 과정은 하지 않는다.

### ex. 2-4

[호이스팅]
2-2 예제의 호이스팅을 마친 상태를 이해하기 쉽게 코드 순서대로 쓴 예제

### ex. 2-5

[호이스팅]
호이스팅을 먼저 한 후, 할당이 되는 것을 유의하여 결과를 보자.

### ex. 2-6

[호이스팅]
2-5 예제의 호이스팅을 마친 상태를 이해하기 쉽게 코드 순서대로 쓴 예제

### ex. 2-7

[호이스팅]
2-5 예제의 함수 선언문을 함수 표현식으로 바꾸어 이해하기 쉽게 코드 순서대로 쓴 예제

### ex. 2-8

[함수를 정의하는 세 가지 방식]

- 함수 선언문
- 함수 표현식
- 기명 함수 표현식

### ex. 2-9

[함수 선언문과 함수 표현식]

- 호이스팅 시,
  함수 선언문은 function sum이 선언,
  함수 표현식은 identifier multiply가 선언됨.(할당은 expression 때 - 오류 발생)

### ex. 2-10

2-9 예제를 호이스팅이 마친 상태로 이해하기 쉽게 변환하는 예제
함수 선언문은 전체를 호이스팅하고, 함수 표현식은 선언부(identifer)만 끌어올린다(예제 - 오류).

### ex. 2-11

[함수 선언문의 위험성]

앞서서 선언한 함수와 같은 이름을 가진 함수를 함수 선언문으로 뒤의 코드에 선언하게 되면,
호이스팅 때문에 같은 이름을 가진 함수는 제일 마지막의 함수 선언문으로 덮어씌워지게된다.
앞에 정의한 함수를 써야하는데, 맨 마지막에 함수 선언문으로 정의한 함수가 나오게 되면 값의 오류가 발생한다.

### ex. 2-12

[함수 선언문보다는 함수 표현식이 안전]

함수 표현식은 호이스팅 먼저, identifier에 함수의 할당이 나중에 이루어지기 때문에 오류를 확인할 수 있다.

### ex. 2-13

- 스코프 : identifier(식별자)에 대한 유효 범위
- 스코프 체인 : 스코프를 안에서부터 바깥으로 차례로 검색해나가는 것

inner 컨텍스트가 실행될 때 식별자를 찾기 위해 inner LexicalEnvironment를 먼저 참조,
식별자가 없다면 outer 컨텍스트의 LexicalEnvironment를 참조하여 값을 찾는다.
즉, outerEnvironmentReference는 현재 호출된 함수가 선언될 당시의 LexicalEnvironment를 참조한다.
동일한 식별자를 선언한 경우에는 무조건 스코프 체인 상에서 가장 먼저 발견된 식별자에만 접근 가능하다.

### ex. 2-14~16

크롬 전용 - 스코프 체인 확인
예제 2-16 debugger 구문에서 paused 되어서 확인 가능.
